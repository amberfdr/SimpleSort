##排序
###1.内部排序
- 使用内存
####1.1 插入排序
#####1.1.1直接插入排序（最简单）
- 概述：一组元素，从第n个元素开始，后面的元素都是待排序元素，第n个元素前都是已经排好序的，将待排序元素temp与已排序好的元素进行比较（从后往前），如果大于temp，该元素后移，直至元素arr[index]小于temp，那temp就插入[index+1]下标的位置。
- 稳定排序
- 条件：
  - 一条记录
  - 有序表
- return
  - 新的，记录数增1的有序表  
#####1.1.2希尔排序（Shell's Sort）也叫缩小增量排序
- 概述：假设一个待排的d0长度的序列，先选取一个增量d1(d1 < d0)，将所有距离为d1长度的元素，分为一组，然后对这些小组分别进行直接插入排序，得到第一次排序的结果；以此类推，选取第二个增量d2(d2<d1)....直至dn=1，即所有记录放在所有同一组进行直接插入排序为止。
- 稳定性：由于一次插入排序是稳定的，但多次插入排序就打乱了同个元素的相对定位，所以是Shell's Sort不是稳定的
- 不稳定排序
####1.2 选择排序
#####1.2.1简单选择排序
- 最优的时候：就是开始就是正序，并不需要移动元素。
- 不稳定排序
#####1.2.2堆排序

####1.3 交换排序
#####1.3.1冒泡排序（从小到大排序）
- 概述：假设从前往后，紧邻两个元素，两两比较，如果d0 > d1,两个元素交换，直到没有交换元素为止。
#####1.3.2快速排序
- 概述：快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
     从数列中挑出一个元素，称为 “基准”（pivot）；
     重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
     递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序
####1.4 归并排序
####1.5 基数排序
###2.外部排序
- 内存和外存结合使用
